# -*- tcl -*-
# huddle.test:  tests for the huddle library.
#
# Copyright (c) 2008 by KATO Kanryu <kanryu6@users.sourceforge.net>
# All rights reserved.
#

# --------------------------------------------------------------------

if {[lsearch [namespace children] ::tcltest] == -1} {
    # single test
    set selfrun 1
    lappend auto_path [pwd]
    package require tcltest
    namespace import ::tcltest::*
    
    source huddle.tcl
    package require json

    proc dictsort {dict} {
        array set a $dict
        set out [list]
        foreach key [lsort [array names a]] {
            lappend out $key $a($key)
        }
        return $out
    }
} else {
    # all.tcl
    source [file join \
        [file dirname [file dirname [file join [pwd] [info script]]]] \
        devtools testutilities.tcl]

    testsNeedTcl     8.5
    testsNeedTcltest 2
    #testsNeed dict 1

    support {
	use json/json.tcl json
    }
    testing {
        useLocal huddle.tcl huddle
    }
}

# --------------------------------------------------------------------

test huddle-1.1 "test of huddle create" -body {
    set upper [huddle create a b c d]
} -result {HUDDLE {D {a {s b} c {s d}}}}

test huddle-1.2 "test of huddle create" -body {
    set upper2 [huddle create e f g h]
    set upper3 [huddle create i j k l]
    set folding [huddle create bb $upper cc $upper2]
} -result {HUDDLE {D {bb {D {a {s b} c {s d}}} cc {D {e {s f} g {s h}}}}}}

test huddle-1.3 "test of huddle create" -body {
    set folding [huddle create dd $folding ee $upper3]
    set data_dict $folding
} -result {HUDDLE {D {dd {D {bb {D {a {s b} c {s d}}} cc {D {e {s f} g {s h}}}}} ee {D {i {s j} k {s l}}}}}}

test huddle-1.4 "test of huddle create" -body {
    huddle get $folding dd
} -result {HUDDLE {D {bb {D {a {s b} c {s d}}} cc {D {e {s f} g {s h}}}}}}

test huddle-1.5 "test of huddle create" -body {
    huddle get $folding dd cc
} -result {HUDDLE {D {e {s f} g {s h}}}}

test huddle-1.6 "test of huddle create" -body {
    huddle get_stripped $folding dd
} -result {bb {a b c d} cc {e f g h}}

test huddle-1.7 "test of huddle create" -body {
    huddle get_stripped $folding dd cc
} -result {e f g h}

test huddle-1.8 "test of huddle create" -body {
    huddle type $folding dd
} -result {dict}

test huddle-1.9 "test of huddle create" -body {
    huddle type $folding dd cc
} -result {dict}

test huddle-1.10 "test of huddle create" -body {
    huddle type $folding dd cc g
} -result {string}

test huddle-2.1 "test of huddle list" -body {
    set upper [huddle list a b c d]
} -result {HUDDLE {L {{s a} {s b} {s c} {s d}}}}

test huddle-2.2 "test of huddle list" -body {
    set upper2 [huddle list e f g h]
    set folding [huddle list i $upper j k $upper2]
} -result {HUDDLE {L {{s i} {L {{s a} {s b} {s c} {s d}}} {s j} {s k} {L {{s e} {s f} {s g} {s h}}}}}}

test huddle-2.3 "test of huddle list" -body {
    set folding [huddle list $folding t u]
    set data_list $folding
} -result {HUDDLE {L {{L {{s i} {L {{s a} {s b} {s c} {s d}}} {s j} {s k} {L {{s e} {s f} {s g} {s h}}}}} {s t} {s u}}}}

test huddle-2.4 "test of huddle list" -body {
    huddle get $folding 0
} -result {HUDDLE {L {{s i} {L {{s a} {s b} {s c} {s d}}} {s j} {s k} {L {{s e} {s f} {s g} {s h}}}}}}

test huddle-2.5 "test of huddle list" -body {
    huddle get $folding 0 1
} -result {HUDDLE {L {{s a} {s b} {s c} {s d}}}}

test huddle-2.6 "test of huddle list" -body {
    huddle get_stripped $folding 0
} -result {i {a b c d} j k {e f g h}}

test huddle-2.7 "test of huddle list" -body {
    huddle get_stripped $folding 0 1
} -result {a b c d}

test huddle-2.8 "test of huddle list" -body {
    huddle type $folding 0
} -result {list}

test huddle-2.9 "test of huddle list" -body {
    huddle type $folding 0 1
} -result {list}

test huddle-2.10 "test of huddle list" -body {
    huddle type $folding 0 1 3
} -result {string}

test huddle-2.11 "test of huddle list" -body {
    huddle get_stripped {HUDDLE {L {{s a} {L {}} {s c}}}}
} -result {a {} c}

#test huddle-3.1 "test of huddle jsondump" {[info tclversion] >= 8.5} {
#    # build a huddle container from normal tcl's container(multi rank dict/list)
#    proc huddle_build {data} {
#        foreach {key val} $data {
#            if {$key eq "layers"} {
#                foreach {l} [dict get $data layers] {
#                    lappend subs [huddle_build $l]
#                }
#                set val [eval huddle list $subs]
#            }
#            lappend result $key $val
#        }
#        return [eval huddle create $result]
#    }
#    set fd [open [asset layers.txt] r]
#    set json1 [read $fd]
#    close $fd
#
#    set data [json::json2dict $json1]
##    set data [huddle_build $data]
##
##    set json2 [huddle jsondump $data]
##    expr $json1 eq $json2
##    set json2
#} {1}

test huddle-3.2 "test of huddle jsondump" -body {
    huddle jsondump {HUDDLE {L {{L {{s i} {s baa} {s k} {L {{num 1.0} {b true} {s g} {s h}}}}} {s t}}}}
} -result {[
  [
    "i",
    "baa",
    "k",
    [
      1.0,
      true,
      "g",
      "h"
    ]
  ],
  "t"
]}


test huddle-3.3 "test of huddle jsondump" -body {
    set huddle1 {HUDDLE {D {dd {D {bb {D {a {s baa} c {s {d a}}}} cc {D {g {s h}}}}} ee {D {i {s j} k {num 1} j {s { m\a}}}}}}}
    set json1 [huddle jsondump $huddle1]
    set json2 {{
  "dd": {
    "bb": {
      "a": "baa",
      "c": "d a"
    },
    "cc": {"g": "h"}
  },
  "ee": {
    "i": "j",
    "k": 1,
    "j": " m\\a"
  }
}}
    
    if {$json1 == $json2} {
    return 1
    } else {
    return 0
    }
} -result {1}


test huddle-3.4 "test of huddle compile" -body {
    set huddle1 {HUDDLE {D {dd {D {bb {D {a {s baa} c {s {d a}}}} cc {D {g {s h}}}}} ee {D {i {s j} k {num 1} j {s { m\a}}}}}}}
    set json1 {{
  "dd": {
    "bb": {
      "a": "baa",
      "c": "d a"
    },
    "cc": {"g": "h"}
  },
  "ee": {
    "i": "j",
    "k": 1,
    "j": " m\\a"
  }
}}
    
    set data [json::json2dict $json1]
    set data [huddle compile {dict dd {dict * dict} ee {dict k number * string}}  $data]
    huddle equal $huddle1 $data
} -result {1}

test huddle-3.5 "test of huddle jsondump - null handling" -body {
    huddle jsondump {HUDDLE null}
} -result {null}

test huddle-3.6 "test of huddle jsondump - dict and null handling" -body {
    huddle jsondump {HUDDLE {D {a {s foo} b null}}}
} -result {{
  "a": "foo",
  "b": null
}}

# ... Tests of addStrings ...
#     (Requires introspection of parser state)

test huddle-4.1 "test of huddle set" -body {
    huddle set data_dict dd bb a baa
} -result {HUDDLE {D {dd {D {bb {D {a {s baa} c {s d}}} cc {D {e {s f} g {s h}}}}} ee {D {i {s j} k {s l}}}}}}

test huddle-4.2 "test of huddle remove" -body {
    set data_dict [huddle remove $data_dict dd cc e]
} -result {HUDDLE {D {dd {D {bb {D {a {s baa} c {s d}}} cc {D {g {s h}}}}} ee {D {i {s j} k {s l}}}}}}

test huddle-4.3 "test of huddle set" -body {
    huddle set data_list 0 1 baa
} -result {HUDDLE {L {{L {{s i} {s baa} {s j} {s k} {L {{s e} {s f} {s g} {s h}}}}} {s t} {s u}}}}

test huddle-4.4 "test of huddle remove" -body {
    set data_list [huddle remove $data_list 0 2]
} -result {HUDDLE {L {{L {{s i} {s baa} {s k} {L {{s e} {s f} {s g} {s h}}}}} {s t} {s u}}}}

test huddle-4.5 "test of huddle equal" -body {
    huddle equal $data_dict {HUDDLE {D {dd {D {bb {D {a {s baa} c {s d}}} cc {D {g {s h}}}}} ee {D {i {s j} k {s l}}}}}}
} -result 1

test huddle-4.6 "test of huddle equal" -body {
    huddle equal $data_dict {HUDDLE {D {dd {D {bb {D {a {s lll} c {s d}}} cc {D {g {s h}}}}} ee {D {i {s j} k {s l}}}}}}
} -result 0

test huddle-4.7 "test of huddle equal" -body {
    huddle equal $data_dict {HUDDLE {D {dd {D {bb {D {a {s baa} c {s d}}} cc {D {g {s h}}}}} ee {D {i {s j} k {s l} j {s m}}}}}}
} -result 0

test huddle-4.8 "test of huddle equal" -body {
    huddle equal $data_list {HUDDLE {L {{L {{s i} {s baa} {s k} {L {{s e} {s f} {s g} {s h}}}}} {s t} {s u}}}}
} -result 1

test huddle-4.9 "test of huddle equal" -body {
    huddle equal $data_list {HUDDLE {L {{L {{s i} {s kkk} {s k} {L {{s e} {s f} {s g} {s h}}}}} {s t} {s u}}}}
} -result 0

test huddle-4.10 "test of huddle equal" -body {
    huddle equal $data_list {HUDDLE {L {{L {{s i} {s baa} {s k} {L {{s e} {s f} {s g} {s h}}}}} {s t}}}}
} -result 0

test huddle-5.1 "test of huddle boolean" -body {
    huddle true
} -result {HUDDLE {b true}}

test huddle-5.2 "test of huddle boolean" -body {
    huddle false
} -result {HUDDLE {b false}}

test huddle-6.1 "test of huddle null" -body {
    huddle null
} -result {HUDDLE null}

test huddle-7.1 "test of huddle number" -body {
    huddle number -4.5E-6
} -result {HUDDLE {num -4.5E-6}}


test huddle-8.1 "test of complex data structure using the new types: number, boolean and null" -body {
    huddle create key1 var1 key2 [huddle number 4] key3 [huddle list [huddle null] sadf [huddle true]]
} -result {HUDDLE {D {key1 {s var1} key2 {num 4} key3 {L {null {s sadf} {b true}}}}}}


test huddle-9.1 "test of huddle exists" -body {
    set obj [huddle list [huddle create key1 2 key3 4] 1 2 [huddle list  1 2 [huddle list 1 2]] ]
    huddle exists $obj 0 key1
} -result {1}

test huddle-9.2 "test of huddle exists" -body {
    set obj [huddle list [huddle create key1 2 key3 4] 1 2 [huddle list  1 2 [huddle list 1 2]] ]
    huddle exists $obj 3 2 1
} -result {1}

test huddle-9.1 "test of huddle exists" -body {
    set obj [huddle list [huddle create key1 2 key3 4] 1 2 [huddle list  1 2 [huddle list 1 2]] ]
    huddle exists $obj 0 key1
} -result {1}

test huddle-9.3 "test of huddle exists" -body {
    set obj [huddle list [huddle create key1 2 key3 4] 1 2 [huddle list  1 2 [huddle list 1 2]] ]
    huddle exists $obj 3 3 1
} -result {0}

test huddle-10.1 "test of huddle clone" -body {
    set obj [huddle list item0 item1 [huddle create key0 value0 key1 value1]]
    huddle clone $obj
} -result {HUDDLE {L {{s item0} {s item1} {D {key0 {s value0} key1 {s value1}}}}}}


test huddle-11.1 "test of huddle superclass" -body {
    
    namespace eval ::new_types::mapping {
    
        variable settings
        set settings {
                superclass dict
                publicMethods {mapping}
                tag !!map 
                isContainer yes }
        
        proc mapping {args} {
            if {[llength $args] % 2} {error {wrong # args: should be "huddle mapping ?key value ...?"}}
            set resultL {}
            foreach {key value} $args {
                lappend resultL $key [argument_to_node $value !!str]
            }

            return [wrap [list !!map $resultL]]
        }
        
    }
    
    namespace eval ::new_types::str {
        
            variable settings
            set settings {
                    superclass string
                    publicMethods {}
                    isContainer no
                    tag !!str
            }
    }
    
    huddle addType ::new_types::mapping
    huddle addType ::new_types::str

    set a [huddle mapping key1 var1]
    huddle append a key2 [huddle mapping key3 var3]
} -result {HUDDLE {!!map {key1 {!!str var1} key2 {!!map {key3 {!!str var3}}}}}}

test huddle-12.0 {ticket [d0e1cf6be1]: jsondump added types} -setup {
    namespace eval ::map {
	variable settings {
	    publicMethods {jsondump}
	    isContainer   yes
	    tag           !!map
	}
    }
    proc ::map::jsondump {obj {offset "  "} {newline "\n"} {begin {}}} {
	# strip huddle and type markers, then ...
	set data [lindex $obj 1 1]
	# ... rewrap into the dict the map is an alias for, and dump
	return [::huddle::jsondump [list HUDDLE [list D $data]] $offset $newline $begin]
    }
    huddle addType ::map
} -body {
    huddle jsondump {HUDDLE {!!map {a {s fox} b {b true}}}}
} -cleanup {
    namespace delete ::map
} -result {{
  "a": "fox",
  "b": true
}}

# Tests of `isHuddle`
# ------------------
test huddle-13.1.1 "test of huddle isHuddle" -body {
    huddle isHuddle {}
} -result 0

test huddle-13.1.2 "test of huddle isHuddle" -body {
    huddle isHuddle {HUDDLE}
} -result 0

test huddle-13.1.3 "test of huddle isHuddle" -body {
    huddle isHuddle {HUDDLE {}}
} -result 0

test huddle-13.1.4 "test of huddle isHuddle" -body {
    huddle isHuddle {HUDDLE {s string}}
} -result 1

test huddle-13.1.5 "test of huddle isHuddle" -body {
    huddle isHuddle {HUDDLE null}
} -result 1

test huddle-13.1.6 "test of huddle isHuddle" -body {
    huddle isHuddle {HUDDLE {b true}}
} -result 1

test huddle-13.1.7 "test of huddle isHuddle" -body {
    huddle isHuddle {HUDDLE {b false}}
} -result 1

test huddle-13.1.8 "test of huddle isHuddle" -body {
    huddle isHuddle {HUDDLE {num -4.5E-6}}
} -result 1

test huddle-13.1.9 "test of huddle isHuddle" -body {
    huddle isHuddle {HUDDLE {unknown whatever}}
} -result 0

test huddle-13.1.10 "test of huddle isHuddle" -body {
    huddle isHuddle {HUDDLE unknown}
} -result 0

test huddle-13.1.11 "test of huddle isHuddle" -body {
    # malformed string
    huddle isHuddle {HUDDLE s}
} -result 0

# Tests of `huddle::strip_node`
# -----------------------------
test huddle-13.2.1 "test of huddle::strip_node" -body {
    huddle::strip_node {s string}
} -result {string}

test huddle-13.2.2 "test of huddle::strip_node" -body {
    huddle::strip_node {null}
} -result {}

test huddle-13.2.3 "test of huddle::strip_node" -body {
    huddle::strip_node {b true}
} -result {true}

test huddle-13.2.4 "test of huddle::strip_node" -body {
    huddle::strip_node {b false}
} -result {false}

test huddle-13.2.5 "test of huddle::strip_node" -body {
    huddle::strip_node {num 5.0}
} -result {5.0}

test huddle-13.2.6 "test of huddle::strip_node" -body {
    huddle::strip_node {unknown whatever}
} -returnCodes {error} -result {This head 'unknown' doesn't exists.}

test huddle-13.2.7 "test of huddle::strip_node" -body {
    huddle::strip_node {}
} -returnCodes {error} -result {This head '' doesn't exists.}

# Tests of `huddle::compile`
# --------------------------
test huddle-13.3.1.1 "test of huddle compile (null, valid arg)" -body {
    set exp {HUDDLE null}
    set act [huddle compile null  ""]; # `data` argument to `compile null` must be an empty string
    huddle equal $act $exp
} -result {1}

test huddle-13.3.1.2 "test of huddle compile (null, invalid arg)" -body {
    set act [huddle compile null  "foo"]; # `data` argument to `compile null` must be an empty string
} -returnCodes {error} -result {Data must be an empty string: 'foo'}

test huddle-13.3.2 "test of huddle compile (string)" -body {
    set exp {HUDDLE {s {hello world}}}
    set act [huddle compile string  "hello world"]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.3.1 "test of huddle compile (number)" -body {
    set exp {HUDDLE {num -2.5}}
    set act [huddle compile number  "-2.5"]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.3.2 "test of huddle compile (number, invalid)" -body {
    set act [huddle compile number  "foo"]
} -result {Bad number: foo} -returnCodes {error}

test huddle-13.3.4.1 "test of huddle compile (boolean true)" -body {
    set exp {HUDDLE {b true}}
    set act [huddle compile boolean  "true"]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.4.2 "test of huddle compile (boolean false)" -body {
    set exp {HUDDLE {b false}}
    set act [huddle compile boolean  "false"]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.4.3 "test of huddle compile (boolean 0)" -body {
    set exp {HUDDLE {b false}}
    set act [huddle compile boolean  0]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.4.4 "test of huddle compile (boolean 1)" -body {
    set exp {HUDDLE {b true}}
    set act [huddle compile boolean  1]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.4.5 "test of huddle compile (boolean 10)" -body {
    set exp {HUDDLE {b true}}
    set act [huddle compile boolean  10]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.4.6 "test of huddle compile (boolean no)" -body {
    set exp {HUDDLE {b false}}
    set act [huddle compile boolean  "no"]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.4.7 "test of huddle compile (boolean yes)" -body {
    set exp {HUDDLE {b true}}
    set act [huddle compile boolean  "yes"]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.5.1 "test of huddle compile (huddle, empty huddle)" -body {
    set exp {HUDDLE {D {}}}
    set act [huddle compile huddle $exp]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.5.2 "test of huddle compile (huddle, empty string)" -body {
    set act [huddle compile huddle {}]
} -result {Data is not a huddle object: } -returnCodes {error}

test huddle-13.3.5.3 "test of huddle compile (huddle, complex)" -body {
    set exp {HUDDLE {D {s {s "hello world"} n {num 123} b {b true} l {L {{s a} {s b}}} d {D {}}}}};
    set act [huddle compile huddle $exp]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.6.1 "test of huddle compile (unknown type)" -body {
    set act [huddle compile foo "bar"]
} -result {Invalid type: 'foo'} -returnCodes {error}

test huddle-13.3.7.1 "test of huddle compile (list, default type)" -body {
    set exp {HUDDLE {L {{s a} {s b} {s c}}}};
    set act [huddle compile list {a b c}]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.7.2 "test of huddle compile (list, string type)" -body {
    set exp {HUDDLE {L {{s a} {s b} {s c}}}};
    set act [huddle compile {list string} {a b c}]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.7.3.1 "test of huddle compile (list, number type)" -body {
    set exp {HUDDLE {L {{num 1} {num 2} {num 3}}}};
    set act [huddle compile {list number} {1 2 3}]
    huddle equal $act $exp
} -result {1}

test huddle-13.3.7.3.2 "test of huddle compile (list, number type, invalid arg)" -body {
    set act [huddle compile {list number} {1 a 3}]
} -result {Bad number: a} -returnCodes {error}

test huddle-13.3.7.4 "test of huddle compile (list, boolean type)" -body {
    set exp {HUDDLE {L {{b true} {b true} {b false}}}};
    set act [huddle compile {list boolean} {1 yes FALSE}]
    huddle equal $act $exp
} -result {1}

# Tests od `huddle::Visit_node_depth_first`
# -----------------------------------------

# a callback that replicates Huddle structure
#
# TODO it is likely not to work for huddle list nodes
#
# Arguments:
#   node_var - name of a huddle node variable in the caller's stack frame
#   path - list of tokens making up a DB key
#   args[0] - name of a Huddle object variable
proc cb_rebuild {node_var path args} {
    if {[llength $path] > 0} {
        upvar 1 $node_var node;
        namespace upvar huddle types types;
        upvar 1 [lindex $args 0] obj;

        lassign $node tag value;
        if {$huddle::types(isContainer:$tag) eq "yes"} {
            set subnode [huddle::argument_to_node {} $tag];
        } else {
            set subnode [huddle::argument_to_node $value $tag];
        }

        set root_node [huddle::unwrap $obj];
        unset obj;

        huddle::Apply_to_subnode set root_node [llength $path] $path $subnode;
        set obj [huddle::wrap $root_node];
    }

    return {stop 0 ascend 0 repack 0};
}

# tests the Huddle tree walkthrough
test huddle-14.1 "test of huddle::Visit_node_depth_first" -setup {
    global h;
    set h [huddle create];
} -body {
    set v {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    set node [huddle unwrap $v];
    huddle::Visit_node_depth_first ::cb_rebuild node {} ::h
    return $h;
} -cleanup {
    unset h;
} -result {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}}


# --------------------------------------------------------------------

if {[info exists selfrun]} {
    tcltest::cleanupTests
} else {
    testsuiteCleanup
}
return
